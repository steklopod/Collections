## Типажи последовательностей: Seq, Indexedseq и Linearseq

Типаж [Seq](http://www.scala-lang.org/api/current/scala/collection/Seq.html) представляет последовательности. 
Последовательность является разновидностью [Iterable](https://github.com/steklopod/Collections/blob/master/src/main/resources/readmes/Iterable.md), 
которая имеет длину и элементы которой имеют фиксированные позиции индекса, начиная с 0.

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/seq.jpg "Seq")

Операции с последовательностями, приведенные в таблице ниже, относятся к следующим категориям:

* **Индексирование и длина**: `apply`, `isDefinedAt`, `length`, `index` и `lengthCompare`. Для `Seq` применяемая 
операция означает индексирование; поэтому последовательность типа `Seq[T]` является частичной функцией, которая принимает 
аргумент `Int` (индекс) и которай дает элемент последовательности типа `T`. Другими словами `Seq[T]` расширяет 
`PartialFunction[Int, T]`. Элементы последовательности индексируются от нуля до длины последовательности минус единица. 
Метод `length` в последовательностях является псевдонимом метода `size` общих коллекций. Метод `lengthCompare` позволяет
 сравнивать длины последовательностей с `Int`, даже если последовательности имеют бесконечную длину.
 
* **Поиск по индексу**: `indexOf`, `lastIndexOf`, `indexOfSlice`, `lastIndexOfSlice`, `indexWhere`, `lastIndexWhere`, 
`segmentLength`, `prefixLength`, которые возвращают индекс элемента, равного заданному значению или соответствующему 
некоторому предикату.
 
* **Сложение**: `+:`, `:+`, `padTo`, которые возвращают новые последовательности, полученные добавлением элементов в 
начале или в конце последовательности.

* **Обновление**: `updated`, `patch`, которые возвращают новую последовательность, полученную путем замены некоторых 
элементов исходной последовательности.

* **Сортировка**:  `sorted`, `sortWith`, `sortBy`, которые сортируют элементы последовательности в соответствии с различными критериями.

* **Реверсивные операции**: `reverse`, `reverseIterator`, `reverseMap`, которые возвращают или обрабатывают элементы последовательности в обратном порядке.

* **Сравнения**: `startWith`, `endsWith`, `contains`, `containsSlice`, `corresponds`, которые связывают две последовательности или ищут элемент в последовательности.

* **Мультимножества (пересечения)** `intersect`, `diff`, `union`, `distinct`, которые выполняют операции в элементах двух последовательностей или удаляют дубликаты.

Если последовательность изменена, она предлагает дополнительно метод обновления побочных эффектов, который позволяет 
обновлять элементы последовательности. Как всегда в Scala, синтаксис, подобный `seq(idx) = elem`, является просто 
сокращением для `seq.update(idx, elem)`, поэтому обновление дает удобный синтаксис присваивания бесплатно. Обратите 
внимание на разницу между обновлением и обновлением. обновление изменяет элемент последовательности на месте и доступно 
только для изменяемых последовательностей. обновление доступно для всех последовательностей и всегда возвращает новую 
последовательность вместо изменения оригинала.

>Операции в классе Seq

Метод                     | Что делает          
------------------------- | --------------------
**Абстрактный метод**     |
`xs indexOf x`            |  Индекс первого элемента в `xs`, равный `x` (существует несколько вариантов).
`xs lastIndexOf x`        |  Диапазон индексов `xs`, простирающийся от `0` до `xs.length - 1`.
`xs isDefinedAt i`        |  Проверяет, содержится ли `i` в `xs.indices`.
`xs.length`               |  Длина последовательности (такая же, как `size`).
`xs lengthCompare n`      |  Возвращает `-1`, если `xs` короче `n`, `+1`, если оно длиннее, и `0`, если оно имеет длину `n`. Работает, даже если последовательность бесконечна, например `Stream.from(1) lengthCompare 42` равна `+1`.
**Поиск по индексу**      |
`xs indexOf x`            | Индекс первого элемента в `xs`, равный `x` (существует несколько вариантов).
`xs lastIndexOf x`        | Индекс последнего элемента в `xs` равен `x` (существует несколько вариантов).
`xs indexOfSlice ys`      | Первый индекс `xs` такой, что последовательные элементы, начиная с этого индекса, образуют последовательность `ys`.
`xs lastIndexOfSlice ys`  | Последний индекс `xs` такой, что последовательные элементы, начиная с этого индекса, образуют последовательность `ys`.
`xs indexWhere p`         | Индекс первого элемента в `xs`, который удовлетворяет `p` (существует несколько вариантов).
`xs segmentLength (p, i)` | Длина самого длинного непрерывного сегмента элементов в `xs`, начиная с `xs(i)`, все они удовлетворяют предикату `p`.
`xs prefixLength p`       | Длина самого длинного префикса элементов из `xs`, которые удовлетворяют предикату `p`.
**Добавление**            |
`x +: xs`                 | Новая последовательность, состоящая из `x`, добавленного к началу `xs`.
`xs :+ x`                 | Новая последовательность, состоящая из `x`, добавленного к концу `xs`.
`xs padTo (len, x)`       | Последовательность, полученная в результате добавления значения `x` в `xs` до достижения длины `len`.
**Обновления**            |
`xs patch (i, ys, r)`     | Последовательность, полученная в результате замены `r` элементов `xs`, начиная с `i` патчем `ys`.
`xs updated (i, x)`       | Копия `xs` с элементом с индексом `i` заменена на `x`.
`xs(i) = x`               | _(или `written out`, `xs.update(i, x)`, доступно только для `mutable.Seqs`)_. Изменяет элемент `xs` с индексом `i` на `x`.
**Сортировка**            |
`xs.sorted`               | Новая последовательность, полученная путем сортировки элементов `xs` с использованием стандартного упорядочения типа элемента `xs`.
`xs sortWith lt`          | Новая последовательность, полученная путем сортировки элементов `xs` с использованием `lt` в качестве операции сравнения.
`xs sortBy f`             | Новая последовательность, полученная путем сортировки элементов `xs`. Сравнение двух элементов происходит путем сопоставления функции `f` по обоим и сравнения результатов.
**Реверсирование**        |
`xs.reverse`              | Последовательность с элементами `xs` в обратном порядке.
`xs.reverseIterator`      | Итератор, переводящий все элементы `xs` в обратном порядке.
`xs reverseMap f`         | Последовательность, полученная отображением `f` по элементам `xs` в обратном порядке.
**Сравнения**             |
`xs startsWith ys`        | Проверяет, начинается ли `xs` с последовательностью `ys` (существует несколько вариантов).
`xs endsWith ys`          | Проверяет, заканчивается ли `xs` с последовательностью `ys` (существует несколько вариантов).
`xs contains x`           | Проверяет, имеет ли `xs` элемент, равный `x`.
`xs containsSlice ys`     | Проверяет, имеет ли `xs` непрерывную подпоследовательность, равную `ys`.
`(xs corresponds ys)(p)`  | Проверяет, удовлетворяют ли соответствующие элементы `xs` и `ys` двоичному предикату `p`.
**Мультимножества (пересечения)**|
`xs intersect ys`                | Многоуровневое пересечение последовательностей `xs` и `ys`, которое сохраняет порядок элементов в `xs`.
`xs diff ys`                     | Множественная разность последовательностей `xs` и `ys`, которая сохраняет порядок элементов в `xs`.
`xs union ys`                    | Мультимножество; такой же, как xs ++ ys.
`xs.distinct`                    | Подпоследовательность `xs`, которая не содержит дублированных элементов.

Типаж `Seq` имеет два наследника: `LinearSeq` и `IndexedSeq`. Они не добавляют никаких новых операций, но каждый из них
 предлагает разные характеристики производительности. Линейная последовательность имеет эффективные операции с головой 
 и хвостом, тогда как индексированная последовательность имеет эффективные `apply`, `length` и (если изменяемые) `update` 
 операции. Часто используемыми линейными последовательностями являются `scala.collection.immutable.List` и 
 `scala.collection.immutable.Stream`. Часто используемыми индексированными последовательностями являются `scala.Array`
  и `scala.collection.mutable.ArrayBuffer`. Класс `Vector` обеспечивает интересный компромисс между индексированным и 
  линейным доступом. Он имеет характеристики константного времени на индексирующие операции и линейного доступа. 
  Из-за этого векторы являются хорошей основой для шаблонов смешанного доступа, в которых используются как индексированные,
   так и линейные обращения. Позднее вы узнаете больше о векторах.
   
### Буфферы

Важной подкатегорией изменяемых последовательностей является `Buffer`. Он позволяет не только `обновлять` существующие 
элементы, но также `вставлять` элементы, `удалять` элементы и эффективные дополнения новых элементов в конце буффера. 
Основными новыми методами, поддерживаемыми буффером, являются **`+=`** и **`++=`** для добавления элементов в конец, 
`+=:` и `++=:` для добавления спереди, `insert` и `insertAll` для вставки элементов, а также удаления и `-=` для удаления
 элементов. Эти операции суммированы в следующей таблице.

Двумя часто используемыми реализациями буфферов являются `ListBuffer` и `ArrayBuffer`. Как следует из названия,
 `ListBuffer` поддерживается списком и поддерживает эффективное преобразование его элементов в список, тогда как
  `ArrayBuffer` поддерживается массивом и может быть быстро преобразован в него.

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/seq2.png "Seq2")

>Операции в в классе Buffer

Метод                     | Что делает          
------------------------- | --------------------
**Добавление**            |
`buf += x`                | Добавляет элемент `x` в конец буффера и возвращает `buf` как результат.
`buf += (x, y, z)`        | Добавляет заданные элементы в конец буффера.
`buf ++= xs`              | Добавляет все элементы `xs` в в конец буффера.
`x +=: buf`               | Добавляет элементы `x` в начало буффера.
`xs ++=: buf`             | Добавляет все элементы `xs` в начало буффера.
`buf insert (i, x)`       | Вставляет элемент `x` по индексу `i` в буффер.
`buf insertAll (i, xs)`   | Вставляет все элементы в `xs` по индексу `i` в буффер.
**Удаление**              |
`buf -= x`                | Удаляет элемент `x` из буффера.
`buf remove i`            | Удаляет элемент по индексу `i` из буффера.
`buf remove (i, n)`       | Удаляет `n` элементов, начиная с индекса `i` из буффера.
`buf trimStart n`         | Удаляет первые `n` элементов из буффера.
`buf.clear()`             | Удаляет все элементы из буффера.
**Клонирование**          |
`buf.clone`               | Новый буффер с теми же элементами, что и `buf`.


