## Типаж Traversable

В верхней части иерархии коллекции есть `типаж (trait) Traversable`. Его единственная абстрактная операция - `foreach`:

```scala
    def foreach[U](f: Elem => U)
```

Классы коллекции, которые реализуют `Traversable`, просто должны определить этот метод; все другие методы могут быть 
унаследованы от `Traversable`.

Метод `foreach` предназначен для перемещения всех элементов коллекции и применения данной операции `f` к каждому элементу. 
Тип операции: `Elem => U`, где `Elem` - тип элементов коллекции, а `U` - произвольный тип результата. Вызов `f`
 выполняется только для его побочного эффекта; на самом деле любой результат функции `f` отбрасывается методом `foreach`.

`Traversable` также определяет многие конкретные методы, которые перечислены в следующей таблице. 
Эти методы относятся к следующим категориям:

* **Сложение**: `++`, которое объединяет две коллекции вместе или добавляет все элементы итератора к обходу.

* **Map-операции**: `map`, `flatMap` и `collect`, которые производят новую коллекцию, применяя некоторую функцию к элементам коллекции.

* **Конверсии**: `toArray`, `toList`, `toIterable`, `toSeq`, `toIndexedSeq`, `toStream`, `toSet`, `toMap`, 
которые превращают коллекцию `Traversable` в нечто более конкретное. Все эти преобразования возвращают аргумент 
получателя без изменений, если тип времени выполнения коллекции уже соответствует требуемому типу коллекции. 
Например, применение `toList` к списку приведет к самому списку.

* **Копирование**: `copyToBuffer` и `copyToArray`. Как следует из их названий, эти элементы коллекции копий в буфер 
или массив соответственно.

* **Операции с информацией о размере**: `isEmpty`, `nonEmpty`, `size` и `hasDefiniteSize`: 
Traversable-коллекции могут быть конечными или бесконечными. Примером бесконечной проходимой коллекции является 
поток натуральных чисел `Stream.from (0)`. Метод `hasDefiniteSize` указывает, может ли коллекция быть бесконечной. 
Если `hasDefiniteSize` возвращает `true`, если коллекция конечна.

* **Поиска элементов**: `head`, `last`, `headOption`, `lastOption` и `find`. Они выбирают первый или последний элемент 
коллекции, а также первый элемент, соответствующий условию. Обратите внимание, однако, что не все коллекции имеют четко
 определенный смысл того, что означает «первый» и «последний». Например, хэш-набор может хранить элементы в 
 соответствии с их хэш-ключами, которые могут меняться от запуска до запуска. В этом случае «первый» элемент 
 хеш-набора также может быть различным для каждого запуска программы. Коллекция упорядочена, если она всегда дает с
 вои элементы в том же порядке. Большинство коллекций упорядочены, но некоторые (например, хэш-наборы) не отбрасывают 
 порядок, что дает немного дополнительной эффективности. Заказ часто необходим для проведения воспроизводимых тестов и 
 для помощи в отладке. Вот почему коллекции Scala предоставляют упорядоченные альтернативы для всех типов коллекций.
  _Например, упорядоченная альтернатива для HashSet - LinkedHashSet._

* **Поиска элементов в подколлекциях**: `tail`, `init`, `slice`, `take`, `drop`, `takeWhile`, `dropWhile`, `filter`, `filterNot`, `withFilter`. 
Все они возвращают некоторую подсерию, идентифицированную диапазоном индексов или некоторым предикатом.

* **Операции разбиения**: `splitAt`, `span`, `partition`, `groupBy`, которые разбивают элементы этой коллекции на 
несколько подкатегорий.

* **Проверка элементов**: `exists`, `forall`, подсчитывают, какие элементы коллекции тестов имеют заданный предикат.

* **Свертка**: `foldLeft`, `foldRight`, `/:`, `:\`, `reduceLeft`, `reduceRight`, которые применяют двоичную операцию 
к последовательным элементам.

* **Специфичная свертка**: `sum`, `product`, `min`, `max`, которые работают с коллекциями определенных типов (числовые или сопоставимые).

* **Строковые операции**: `mkString`, `addString`, `stringPrefix`, которые предоставляют альтернативные способы 
преобразования коллекции в строку.

* **Вид (View)**: состоящих из двух перегруженных вариантов метода `view`. `View` - это коллекция, которая инициализируется
 лениво. В дальнейшем вы узнаете больше о представлениях.

_Если этот проект окажется полезным тебе - нажми на кнопочку `star` в правом верхнем углу._


Метод                     | Что делает          
------------------------- | --------------------
**Абстрактный метод**     |
`xs foreach f`            | Выполняет функцию `f` для каждого элемента `xs`
**Сложение**              | 
`xs ++ ys`                | Коллекция, состоящая из элементов как `xs`, так и `ys`. `ys` представляет собой коллекцию `TraversableOnce`, то есть либо `Traversable`, либо `Iterator`.
**Map-операции**          |
`xs map f`                | Коллекция, полученная от применения функции `f` к каждому элементу из `xs`.
`xs flatMap f`            | Коллекция, полученная от применения функции сбора значений `f` к каждому элементу из `xs`, а затем объединяет ее.
`xs collect f`            | Коллекция, полученная от применения частичной функции `f` к каждому элементу из `xs`, для которого он определен и собирающий результаты.
**Конверсии**             |
`xs.toArray`              | Преобразует коллекцию в массив.
`xs.toList`               |
`xs.toIterable`           | 
`xs.toSeq`                | 
`xs.toIndexedSeq`         | 
`xs.toStream`             | 
`xs.toSet`                | 
`xs.toMap`                | Преобразует коллекцию пар ключ / значение в Map. Если в коллекции нет пар в качестве элементов, вызов этой операции приводит к ошибке статического типа.
**Копирование**             |
`xs copyToBuffer buf`       | Копирует все элементы коллекции в буфер `buf`
`xs copyToArray(arr, s, n)` | Копирует не более `n` элементов коллекции в массив `arr`, начинающийся с индекса `s`. _Последние два аргумента являются необязательными._
`xs copyToBuffer buf`       | Копирует все элементы коллекции в буфер `buf`
**Операции с информацией о размере** |
`xs.isEmpty`                         | Проверяет, пуста ли коллекция.
`xs.nonEmpty`                        | Проверяет, содержит ли коллекция элементы.
`xs.size`                            | Кол-во элементов в коллекции.
`xs.hasDefiniteSize`                 | `true` если коллекция имеет конечный размер.
**Поиска элементов** |
`xs.head`            | Первый элемент коллекции (или некоторый элемент, если не задан порядок).
`xs.headOption`      | Первый элемент `xs` в Option-типе или `None`, если `xs` пуст.
`xs.last`            | Последний элемент коллекции (или некоторый элемент, если не задан порядок).
`xs.lastOption`      | Последний элемент `xs` в Option-типе или `None`, если `xs` пуст.
`xs find p`          | Option-тип, содержащая первый элемент в `xs`, который удовлетворяет предикату `p`, или `None`, если ни один элемент не подходит.
**Подколлекции**     |
`xs.tail`            | Остальная часть коллекции, кроме `xs.head`.
`xs.init`            | Остальная часть коллекции, кроме `xs.last`.
`xs slice (from, to)`| Коллекция, состоящая из элементов в некотором диапазоне индексов `xs` (от from и до to не включая).
`xs take n`          | Коллекция, состоящая из первых `n` элементов `xs` (или некоторых произвольных n элементов, если не определен порядок).
`xs drop n`          | Остальная часть коллекции, кроме `xs`, принимает `n`.
`xs takeWhile p`     | Самый длинный префикс элементов в коллекции, которые удовлетворяют `p`.
`xs dropWhile p`     | Коллекция без самого длинного префикса элементов, удовлетворяющих всем требованиям.
`xs filter p`        | Коллекция, состоящая из тех элементов `xs`, которые удовлетворяют предикату `p`.
`xs withFilter p`    | Нестрогий фильтр коллекции. Последующие вызовы `map`, `flatMap`, `foreach` и `withFilter` будут применяться только к тем элементам `xs`, для которых условие `p` истинно.
`xs filterNot p`     | Коллекция, состоящая из тех элементов `xs`, которые не удовлетворяют предикату `p`.
**Разделение**       |
`xs splitAt n`       | Разделяет `xs` в позиции, создав пару коллекций `(xs take n, xs drop n)`.
`xs span p`          | Разделяет `xs` в соответствии с предикатом, предоставляя пару коллекций `(xs takeWhile p, xs.dropWhile p)`.
`xs partition p`     | Разделяет `xs` на пару коллекций; один с элементами, которые удовлетворяют предикату `p`, а другой - с элементами, которые этого не делают, давая пару коллекций `(xs filter p, xs.filterNot p)`.
`xs groupBy f`       | Разделяет `xs` на отображение наборов в соответствии с дискриминаторной функцией `f`.


![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/collection_methods_1.png "collection_methods_1")

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/collection_methods_2.png "collection_methods_2")

[<= содержание](https://github.com/steklopod/Collections/blob/master/readme.md)

[переведено мной отсюда](https://docs.scala-lang.org/overviews/collections/trait-traversable.html)