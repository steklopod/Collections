## Списки (Lists)

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/listFruit.jpg "listFruit")
[Списки](http://www.scala-lang.org/api/current/scala/collection/Map.html) - конечная неизменяемая последовательность. 
Она обеспечивают **доступ за константное время к их первому элементу**, а также к остальной части списка, и у них есть операция с 
постоянным временем для добавления нового элемента в начало списка. Многие **другие операции занимают линейное время**.
       
Основное изменение в 2.8 заключается в том, что класс `List` вместе с его `подклассом ::` и его `подобъектом Nil` теперь 
определен в пакете `scala.collection.immutable`, где он логически и должен быть. Есть еще псевдонимы для `List`, `Ni`l и `::`
 в пакете `scala`, поэтому с точки зрения пользователя списки могут быть доступны по-прежнему.![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/lists.png "lists")                                                                     
                                                                  
Другое изменение заключается в том, что списки теперь более тесно интегрируются в структуру коллекций и являются менее
 конкретным случаем, чем раньше. Например, все многочисленные методы, которые первоначально были включены в объект 
 сопутствующего списка, устарели. Они заменяются едиными методами создания, унаследованными каждой коллекцией.

Списки Скала очень похожи на массивы, что означает, что все элементы списка имеют один и тот же тип, но есть два важных 
отличия. Во-первых, списки неизменяемы. Во-вторых, списки представляют собой `связанный список`.

```scala
    // Пустой список
    val empty: List[Nothing] = List()
    
    // Список списков чисел
    val dim: List[List[Int]] =
       List(
          List(1, 0, 0),
          List(0, 1, 0),
          List(0, 0, 1)
       )
```

Все списки могут быть определены с использованием двух основных строительных блоков, `хвоста Nil` и `::`, который 
произносится как **cons**. `Nil` также представляет пустой список. Все приведенные выше списки можно определить следующим образом.

```scala
    val фрукты = "яблоки" :: ("апельсины" :: ("груши" :: Nil))
    
    val пустой = Nil
    
    val dim = (1 :: (0 :: (0 :: Nil))) ::
              (0 :: (1 :: (0 :: Nil))) ::
              (0 :: (0 :: (1 :: Nil))) :: Nil
```

### Основные операции над списками

```scala
    object Lists extends App {
      val фрукты = "яблоки" :: ("апельсины" :: ("груши" :: Nil))
      val числа = Nil
    
      println( "'Голова' списка фруктов: " + фрукты.head )
      println( "'Хвост'  списка фруктов: " + фрукты.tail )
      println( "Список фруктов пуст?: " + фрукты.isEmpty )
      println( "Список чисел   пуст?: " + числа.isEmpty )
    }
```
> вывод:
```text
    'Голова' списка фруктов: яблоки
    'Хвост'  списка фруктов: List(апельсины, груши)
    Список фруктов пуст?: false
    Список чисел   пуст?: true
```

### Конкатенация списков

Вы можете использовать либо `:::` оператор, либо `List.:::()` метод, либо `List.concat()` для добавления двух или более 
списков:

```scala
    object ListsConcat extends App {
      val фрукты1 = "яблоки" :: ("апельсины" :: ("груши" :: Nil))
      val фрукты2 = "манго"  :: ("банан" :: Nil)
    
      // :::
      var фрукты = фрукты1 ::: фрукты2
        println( "фрукты1 ::: фрукты2 : " + фрукты )
    
      // List.:::() 
      фрукты = фрукты1.:::(фрукты2)
        println( "фрукты1.:::(фрукты2) : " + фрукты )
    
      // List.concat(List[F], List[F])
      фрукты = List.concat(фрукты1, фрукты2)
        println( "List.concat(фрукты1, фрукты2) : " + фрукты  )
    }
```

> вывод:
```text
    фрукты1 ::: фрукты2 : List(яблоки, апельсины, груши, манго, банан)
    фрукты1.:::(фрукты2) : List(манго, банан, яблоки, апельсины, груши)
    List.concat(фрукты1, фрукты2) : List(яблоки, апельсины, груши, манго, банан)
```

### Создание единообразных списков

Вы можете использовать метод `List.fill()`, создавая список, состоящий из нуля или более копий одного и того же элемента:

```scala
object UniformListsCreation extends App {
    val фрукты = List.fill(3)("яблоки") // Повторяет яблоки 3 раза.
    println( "фрукты : " + фрукты  )
}
```

> вывод:
```text
    фрукты : List(яблоки, яблоки, яблоки)
```

### Приведение к плоской структуре с помощью функции 

Вы можете использовать функцию вместе со способом `List.tabulate()` для применения ко всем элементам списка перед 
табуляцией списка. Его аргументы аналогичны аргументам `List.fill`: первый список аргументов дает размеры создаваемого 
списка, а второй описывает элементы списка. Единственное отличие состоит в том, что вместо фиксированных элементов они 
вычисляются из функции:


```scala
    object TabulatingAFunction extends App {
      val квадраты = List.tabulate(6)(n => n * n)  // Создает 5 элементов, используя заданную функцию.
        println( "квадраты : " + квадраты  )       // вывод: "квадраты : List(0, 1, 4, 9, 16, 25)"
    
      val умнож = List.tabulate( 4,5 )( _ * _ )
        println( "умнож : \n" + умнож  )           // вывод: "умнож : 
                                                   // List(List(0, 0, 0, 0, 0), 
                                                   // List(0, 1, 2, 3, 4), 
                                                   // List(0, 2, 4, 6, 8), 
                                                   // List(0, 3, 6, 9, 12))"
    }
```

> :-) темная сторона Скала-колекций:
![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/list-scala_hard.png "list-scala")                                                                     


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[=> Потоки (Streams)](https://github.com/steklopod/Collections/blob/master/src/main/resources/readmes/Concrete-Streams.md)

[<= содержание](https://github.com/steklopod/Collections/blob/master/readme.md)