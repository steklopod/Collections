## Хэш-деревья (Hash Tries), красно-черные деревья (Red-Black Trees), бинарные множества (Immutable BitSets), отображения-списки (ListMaps)

### Хэш-деревья (Hash Tries)

**Хэш-деревья** - это стандартный способ эффективного использования неизменяемых наборов и отображений. Они поддерживаются 
классом [immutable.HashMap](http://www.scala-lang.org/api/2.12.2/scala/collection/immutable/HashMap.html). 
Их представление аналогично векторам в том, что они также являются деревьями, где каждый 
узел имеет 32 элемента или 32 поддерева. Но выбор этих ключей теперь выполняется на основе хэш-кода. Например, чтобы найти 
заданный ключ в отображении, сначала берется хэш-код ключа. Затем самые нижние 5 бит хеш-кода используются для выбора 
первого поддерева, за которым следуют следующие 5 бит и так далее. Выбор останавливается, как только все элементы, 
хранящиеся в узле, имеют хэш-коды, которые отличаются друг от друга в битах, выбранных до этого уровня.

Хэш пытается получить хороший баланс между достаточно быстрыми поисками и разумно эффективными функциональными 
вставками `+` и удалениями `-`. Вот почему они недвусмысленно внедряют реалистичные решения Scala по неизменяемым отображениям
 и наборам. Фактически, Scala имеет дополнительную оптимизацию для неизменяемых наборов и отображений, которые содержат 
 менее пяти элементов. Наборы и отображения с одним или четырьмя элементами хранятся как отдельные объекты, которые просто 
 содержат элементы (или пары ключ / значение в случае карты) в качестве полей. Пустое неизменяемое множество и пустое 
 неизменяемое отображение в каждом случае представляют собой один объект - нет необходимости дублировать память для них, 
 потому что пустой неизменяемый набор или карта всегда остаются пустыми.
 
 ### Красно-черные деревья (Red-Black Trees)

**Красно-черные деревья** представляют собой форму сбалансированного двоичного дерева, где некоторые узлы обозначаются 
как «красные», а другие обозначаются как «черные». Как и любое сбалансированное двоичное дерево, сложность операций над ними
  - выполняется за время, логарифмически пропорционально размеру дерева.

Scala обеспечивает реализацию неизменяемых наборов и отображений, которые используют красно-черное дерево внутри.
 Получите доступ к ним под именами [TreeSet](http://www.scala-lang.org/api/2.12.2/scala/collection/immutable/TreeSet.html) и 
 [TreeMap](http://www.scala-lang.org/api/2.12.2/scala/collection/immutable/TreeMap.html).

```scala
    scala> scala.collection.immutable.TreeSet.empty[Int]
      res11: scala.collection.immutable.TreeSet[Int] = TreeSet()
    
    scala> res11 + 1 + 3 + 3
      res12: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)
```

Красно-черные деревья являются стандартной реализацией `SortedSet` в Scala, потому что они обеспечивают эффективный итератор, 
который возвращает все элементы в отсортированном порядке.

 ### Бинарные множества (Immutable BitSets)

[Бинарное множество](http://www.scala-lang.org/api/2.12.2/scala/collection/immutable/BitSet.html) представляет собой 
набор небольших целых чисел в виде битов большего целого числа. Например, набор бит, содержащий 3, 2 и 0, будет представлен 
как целое число 1101 в двоичном формате, которое равно 13 в десятичном значении.

Внутри битовые наборы используют массив из 64-битных `Long`. Первый `Long` в массиве для целых чисел от 0 до 63, второй 
- от 64 до 127 и т. Д. Таким образом, битовые множества очень компактны, если наибольшее целое число в наборе составляет 
менее нескольких сотен.

Операции с битовыми наборами выполняются очень быстро. Тестирование для включения занимает постоянное время. Добавление 
элемента к набору требует времени, пропорционального количеству длинных в массиве бит множеств, которое обычно является 
небольшим числом. Вот несколько простых примеров использования набора бит:

```scala
    scala> val bits = scala.collection.immutable.BitSet.empty
      bits: scala.collection.immutable.BitSet = BitSet()
   
    scala> val moreBits = bits + 3 + 4 + 4
      moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)
   
    scala> moreBits(3)
      res26: Boolean = true
    
    scala> moreBits(0)
      res27: Boolean = false
```
### Отображения-списки (ListMaps)

[ListMap](http://www.scala-lang.org/api/2.12.2/scala/collection/immutable/ListMap.html) представляет карту как связанный 
список пар ключ-значение. В общем случае операции в отображениях-списках, возможно, придется перебирать все элементы списка.
 Таким образом, операции в отображениях-списках имеют время, линейное по размеру карты. Стандартные неизменные отображения
  почти всегда быстрее. Единственным возможным исключением из этого является то, что карта по какой-то причине построена 
  таким образом, что первые элементы в списке выбираются гораздо чаще, чем другие элементы.

```scala
    scala> val map = scala.collection.immutable.ListMap(1->"one", 2->"two")
      map: scala.collection.immutable.ListMap[Int,java.lang.String] =
           Map(1 -> one, 2 -> two)
    
    scala> map(2)
     res30: String = "two"
```

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Collections/blob/master/readme.md)
