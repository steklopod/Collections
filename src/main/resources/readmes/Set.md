## Типаж Set (множество/набор)

[Set](https://www.scala-lang.org/api/2.12.3/scala/collection/immutable/Set.html) - это коллекция объектов, 
которая не содержат повторяющихся элементов, т.е. где все элементы являются уникальными. 

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/scala-sets.jpg "Set")

>Операции в классе Set

* **Проверка**: `contains`, `apply`, `subsetOf`. Метод `contains` спрашивает, содержит ли набор данный элемент. Метод `apply`
 для набора такой же, как и `contains`, поэтому запись `set(elem)` эквивалентна  `set contains elem`. Это означает, что наборы 
 также могут использоваться в качестве тестовых функций, возвращающих `true` для элементов, которые они содержат.

```scala 
    scala> val fruit = Set("apple", "orange", "peach", "banana")
    fruit: scala.collection.immutable.Set[java.lang.String] = Set(apple, orange, peach, banana)
    scala> fruit("peach")
    res0: Boolean = true
    scala> fruit("potato")
    res1: Boolean = false
```

* **Добавление**: `+` и `++`, которые добавляют один или несколько элементов в набор, возвращая новый набор.

* **Удаление**: `-`, `--`, которые удаляют один или несколько элементов из набора, что создает новый набор.

* **Бинарные операции** для объединения, пересечения и установки разности. Каждая из этих операций существует в двух 
формах: алфавитном и символьном. Алфавитные версии - `intersect`, `union` и `diff`, тогда как символьные версии - 
`&`, `|` и `&~`. На самом деле, `++`, который `Set` наследует от `Traversable`, можно рассматривать как еще один 
псевдоним `union` или `|`, за исключением того, что `++` принимает аргумент `Traversable`, тогда как `union` и `|` принимает наборы.

Метод                     | Что делает          
------------------------- | --------------------
**Проверка**              |
`xs contains x`           | Проверяет, является ли `x` элементом `xs`
`xs(x)`                   | То же что и `xs contains x`
`xs subsetOf ys`          | Проверяет, является ли `xs` подмножеством `ys`
**Добавление**            |
`xs + x`                  | Проверяет, является ли `xs` подмножеством `ys`
`xs + (x, y, z)`          | Набор, содержащий все элементы `xs`, а также данные дополнительные элементы
`xs + x`                  | Множество содержит все элементы `xs`, а также все элементы `ys`
**Удаление**              |
`xs - x`                  | Множество, содержащее все элементы `xs`, кроме `x`
`xs - (x, y, z)`          | Множество, содержащее все элементы `xs`, за исключением заданных элементов
`xs -- ys`                | Множество, содержащее все элементы `xs`, кроме элементов `ys`
`xs.empty`                | Пустое множество того же класса, что и `xs`
**Бинарные операции**     |
`xs & ys`                 | Пересечение множеств `xs` и `ys`
`xs intersect ys`         | Тоже, что и `xs & ys`
`xs 1 ys`                 | Объединение множеств единиц `xs` и `ys`
`xs union ys`             | Тоже что и  `xs 1 ys`
`xs &~ ys`                | Разница множеств `xs` и `ys`
`xs diff ys`              | Тоже что и `xs &~ ys`

**Изменяемые множества** предоставляют операции добавления, удаления или обновления.

>Операции в классе mutable.Set

Метод                     | Что делает          
------------------------- | --------------------
**Добавление**            |
`xs += x`                 | Добавляет элемент `x` в множество `xs` как побочный эффект и возвращает `xs`
`xs += (x, y, z)`         | Добавляет заданные элементы в множество `xs` и возвращает `xs`
`xs ++= ys`               | Добавляет все элементы в `ys` в множество `xs` и возвращает `xs`
`xs add x`                | Добавляет элемент `x` в `xs` и возвращает `true`, если `x` не был в наборе, `false`, если был
**Удаление**              |
`xs -= x`                 | Удаляет элемент `x` из набора `xs` как побочный эффект и возвращает `xs`
`xs -= (x, y, z)`         | Удаляет заданные элементы из набора `xs`возвращает `xs`
`xs --= ys`               | Удаляет все элементы из `ys` из набора `xs` и возвращает `xs`
`xs remove x`             | Удаляет элемент `x` из `xs` и возвращает `true`, если `x` ранее содержался в наборе, `false`, если его не было
`xs retain p`             | Оставляет только те элементы из `xs`, которые удовлетворяют предикату `p`
`xs.clear()`              | Удаляет все элементы из `xs`
**Обновление**            |
`xs(x) = b`               | _(или `xs.update(x, b)`)_.  Если логический аргумент `b` истинен, добавляет `x` в `xs`, в противном случае удаляет `x` из `xs`
**Клонирование**          |
`xs.clone`                | Новый измененный набор с теми же элементами, что и xs

Как и неизменяемый набор, изменяемый предлагает операции `+` и `++` для добавления элементов и операции `-` `--` для 
удаления элементов. Но они реже используется для изменяемых наборов, поскольку они связаны с копированием набора. 
В качестве более эффективной альтернативы изменяемые множества предлагают методы обновления `+=` и `-=`. Операция 
`s += elem` добавляет `elem` в набор `s` как побочный эффект и возвращает в результате мутированный набор. 
Аналогично, `s -= elem` удаляет элемент из набора и возвращает в результате мутированный набор. Кроме того, `+=` и `-=` 
есть также операции с массивом `++=` и `--=`, которые добавляют или удаляют все элементы.

Выбор методов `+=` и `-=` означает, что очень похожий код может работать как с изменяемыми так и неизменяемыми наюорами.
 Рассмотрим сначала следующий диалог REPL, в котором используется **неизменяемое** множество `s`:

```scala
    scala> var s = Set(1, 2, 3)
      s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
      
    scala> s += 4
    scala> s -= 2 // удалит объект 2 (не индекс 2)
    scala> s
      res2: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
```

Мы использовали `+=` и `-=` на `var`-типе `immutable.Set`. Утверждение  `s += 4`, является аббревиатурой для `s = s + 4`.
 Таким образом, он вызывает метод добавления `+` на множестве `s`, а затем возвращает результат переменной `s`. 
 Рассмотрим теперь аналогичное взаимодействие с **изменяемым** множеством:
 
```scala
    scala> val s = collection.mutable.Set(1, 2, 3)
      s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)
      
    scala> s += 4
      res3: s.type = Set(1, 4, 2, 3)
    scala> s -= 2
      res4: s.type = Set(1, 4, 3)
```

Конечный эффект очень похож на предыдущее взаимодействие; мы начинаем с набора `Set(1, 2, 3)` и заканчиваем множеством 
`Set(1, 3, 4)`. Однако, хотя утверждения выглядят одинаково, они делают что-то другое. `s += 4` теперь вызывает 
метод `+=` на изменяемом заданном значении `s`, изменяя набор на месте. Аналогично, `s -= 2` теперь вызывает 
метод `-=` на том же множестве.

Сравнение двух взаимодействий показывает важный принцип. Вы часто можете заменить коллекцию, хранящуюся в `val`, 
на коллекцию хранящуюся в `var`, и наоборот. Это работает, по крайней мере, до тех пор, пока нет ссылок на коллекцию, 
через которые можно наблюдать, была ли она обновлена ​​или была создана новая коллекция.

Изменяемые наборы предоставляют методы `add` и `remove` как варианты `+=` и `-=`. Разница в том, что 
`add` и `remove` возвращают `Boolean`, показывающий, повлияла ли операция на набор.

Текущая реализация по умолчанию изменяемого набора использует хэш-таблицу для хранения элементов набора. По умолчанию 
реализация неизменяемого набора использует представление, которое принимает количество элементов набора. Пустое множество 
представлено просто синглтон-элементом. Наборы размеров до четырех представлены одиночным объектом, который хранит все 
элементы как поля. Помимо этого размера, неизменяемые наборы реализуются как [хэш-деревья](https://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html).

Следствием этих утверждений является то, что множества небольших размеров (скажем, до 4), неизменяемые множества обычно 
более компактны и, следовательно, более эффективны, чем изменяемые множества. Итак, если вы ожидаете, что размер набора
 будет небольшим, попробуйте сделать его неизменным.
 
### Сортированные множества (SortedSet)
 
[SortedSet](http://www.scala-lang.org/api/current/scala/collection/SortedSet.html) - это набор, который создает свои элементы
 _(используя итератор или `foreach`)_ в заданном порядке.  По умолчанию `SortedSet` представляет собой упорядоченное двоичное дерево, 
которое поддерживает инвариант, что все элементы в левом поддереве узла меньше всех элементов в правом поддереве. Таким 
образом, простой обход может возвращать все элементы дерева в порядке возрастания. Класс `immutable.TreeSet` использует 
реализацию красно-черного  дерева для поддержания этого упорядочения и в то же время сохраняет дерево сбалансированным, 
т.е. все пути от корня дерева до листа имеют только один элемент.

Чтобы создать пустой TreeSet, вы можете указать желаемый порядок:

```scala    
    scala> val myOrdering = Ordering.fromLessThan[String](_ > _)
      myOrdering: scala.math.Ordering[String] = ...
```

Затем, чтобы создать пустой TreeSet с этим упорядочением, используйте:

```scala    
     scala> TreeSet.empty(myOrdering)
       res1: scala.collection.immutable.TreeSet[String] = TreeSet()
```

Или вы можете оставить аргумент упорядочения или указать тип элемента или пустой набор. В этом случае будет использоваться 
порядок по умолчанию для типа элемента:

```scala    
     scala> TreeSet.empty[String]
       res2: scala.collection.immutable.TreeSet[String] = TreeSet()
```

Если вы создаете новые наборы из TreeSet (например, путем конкатенации или фильтрации), они будут поддерживать тот же 
порядок, что и исходный набор:

```scala    
    scala> res2 + ("one", "two", "three", "four")
      res3: scala.collection.immutable.TreeSet[String] = TreeSet(four, one, three, two)
```

Сортированные наборы также поддерживают диапазоны элементов. Например, метод `range (диапозон)` возвращает все элементы 
начиная с исходного элемента в, до последнего (не включая). Или метод `from` возвращает все элементы, больше или равный,
 чем начальный элемент в упорядочении набора. Результатом вызова обоих методов снова является отсортированный набор:

```scala    
    scala> res3 range ("one", "two")
      res4: scala.collection.immutable.TreeSet[String] = TreeSet(one, three)
    scala> res3 from "three"
      res5: scala.collection.immutable.TreeSet[String] = TreeSet(three, two)
```

### Bitset
[Bitset](https://www.scala-lang.org/api/2.12.0/scala/collection/BitSet.html)- это наборы неотрицательных целых чисел, 
которые представлены в виде массивов переменного размера бит, упакованных в 64-битные слова. Внутреннее представление [BitSet](http://www.scala-lang.org/api/current/scala/collection/BitSet.html) 
использует массив `Long`. Объем памяти битового набора определяется наибольшим количеством, хранящимся в нем.


```scala    
    val bitSet1: BitSet = BitSet(0, 2, 4, 6, 8)
    println(s"Element 0 = ${bitSet1(0)}")
    println(s"Element 1 = ${bitSet1(1)}")
    println(s"Element 2 = ${bitSet1(2)}")
```

Результат:

```sbtshell    
    Element 0 = true
    Element 1 = false
    Element 2 = true
```

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

* [=> Типаж Map](https://github.com/steklopod/Collections/blob/master/src/main/resources/readmes/Map.md)

[<= содержание](https://github.com/steklopod/Collections/blob/master/readme.md)