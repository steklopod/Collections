## Отображения (Map)

[Отображение](http://www.scala-lang.org/api/current/scala/collection/Map.html) - коллекция, состоящая из пар ключей и 
значений (именованные сопоставления или ассоциации). Объект [Predef](http://www.scala-lang.org/api/current/scala/Predef$.html) 
 предлагает неявное преобразование, которое позволяет писать `ключ -> значение` в качестве альтернативного синтаксиса 
 для пары `(ключ, значение)`. Например, `Map(«x» -> 24, «y» -> 25, «z" -> 26)` эквивалентно `Map((«x», 24), («y», 25), (z ", 26))`
 , но читается лучше.

![alt text](https://github.com/steklopod/Collections/blob/master/src/main/resources/images/map_trait.png "Map")

Основные операции отображений аналогичны действиям на множествах. Они относятся к следующим категориям:

* **Поиск**: `apply`, `get`, `getOrElse`, `contains` и `isDefinedAt`. Данные методы превращают отображения в частичные функции из
 ключей в значения. Основной метод поиска в отображении: **`def get(ключ): Option[Value]`**. 
 Операция `отображение get ключ` проверяет, содержит ли отображение ассоциацию для данного `ключ`а. Если это так, он возвращает 
 связанное значение в монаде **`Some`**. Если данного ключа не содержится в отображении - `get` возвращает **`None`**. Отображения
  так же определяют метод **`apply`**, который возвращает значение, связанное с данным ключом, без его 
  обертки `Option`. Если ключ не определен - возникает исключение.

* **Добавление и обновление**: `+`, `++`, `updated` позволяют добавлять новые привязки к отображению или изменять существующие.

* **Удаление**: `-`, `--` удаляют привязки из отображения.

* **Создание подколлекций**: `keys`, `keySet`, `keysIterator`, `values`, `valuesIterator`, которые возвращают ключи 
отображения и значения отдельно в различных формах.

* **Трансформации**: `filterKeys` и `mapValues`, которые создают новое отображение путем фильтрации и преобразования привязок существующего отображения.

### Операции в классе Map (неизменняемая коллекция)

Метод                     | Что делает          
------------------------- | --------------------
**Поиск**                 |
`ms get k`                | Значение, связанное с ключом `k` в `ms` в монаде `Option`. `None`, если не найдено.
`ms(k)`                   | _(или `ms apply k`) Значение, связанное с ключом `k` в `ms`, или исключение, если не найдено.
`ms getOrElse (k, d)`     | Значение, связанное с ключом `k` в `ms`, или значение по умолчанию, если оно не найдено.
`ms contains k`           | Проверяет, содержит ли `ms` отображение для ключа `k`.
`ms isDefinedAt k`        | Тоже что и `contains`.
**Добавление и обновление**|
`ms + (k -> v)`            | Отображение, содержащее все отображения `мс`, а также отображение `k -> v` от ключа `к` в значение `v`.
`ms + (k -> v, l -> w)`    | -//-
`ms ++ kvs`                | -//-
`ms updated (k, v)`        | -//-
**Удаление**            |
`ms - k`                | Удаляет пару с ключем `k` из `ms`
`ms - (k, l, m)`        | Удаляет все пары с ключями `k, l, m` из `ms`
`ms -- ks`              |  -//-, где `ks` - keySet, т.е. набор ключей
**Создание подколлекций**|
`ms.keys`                | Возвращает `iterable`, содержащий каждый ключ в `ms`.
`ms.keySet`              | `set`, содержащий каждый ключ в `ms`.
`ms.keysIterator`        | `iterator`, содержащий каждый ключ в `ms`.
`ms.values`              | `iterable`, содержащий все значения в `ms`.
`ms.valuesIterator`      | `iterator`, содержащий все значения в `ms`.
**Трансформация**        |
`ms filterKeys p`        | Представление отображения (map view ), содержащее только те сопоставления в `ms`, где ключ удовлетворяет предикату `p`.
`ms mapValues f`         | Представление отображения (map view ), в результате применения функции `f` к каждому значению, связанному с ключом в `ms`.


### Операции в классе mutable.Map (изменняемая коллекция)

Метод                      | Что делает          
-------------------------  | --------------------
**Поиск**                  |
`ms(k) = v`                | _(или `ms.update(x, v)`) Добавляет отображение из ключа `k` в значение `v` для отображения `ms`, перезаписывая любое предыдущее сопоставление `k`.
`ms += (k -> v)`           | Добавляет сопоставление от ключа `k` к значению `v` для сопоставления `ms`  и возвращает самих себя.
`ms += (k -> v, l -> w)`   | Добавляет заданные сопоставления в `ms` и сам возвращает `ms`.
`ms ++= kvs`               | Добавляет все сопоставления в `kvs` в `ms` и сам возвращает `ms`.
`ms put (k, v)`            | Добавляет отображение из ключа `k` в значение `v` в `ms` и возвращает любое значение, ранее связанное с `k` в качестве Option-значения.
`ms getOrElseUpdate (k, d)`| Если ключ `k` определен в `ms`, вернет его связанное значение. В противном случае обновит `ms` с помощью отображения `k->d` и верните d.
**Удаление**               |
`ms -= k`                  | Удаляет отображение с ключом `k` из `ms` в качестве побочного эффекта и сам возвращает `ms`.
`ms -= (k, l, m)`          | Удаляет сопоставления с заданными ключами из `ms` и возвращает сам `ms`.
`ms --= ks`                | -//-, где `ks` - keySet, т.е. набор ключей
`ms remove k`              | Удаляет любое сопоставление с ключом `k` из `ms` и возвращает любое значение, ранее связанное с `k` в Option-типе.
`ms retain p`              | Сохраняет только те сопоставления в `ms`, которые имеют ключ, удовлетворяющий предикату `p`.
`ms.clear()`               | Очищает коллекцию.
**Трансформации**          |
`ms transform f`           | Преобразует все связанные значения в отображение `ms` функцией `f`.
**Клонирование**           |
`ms.clone`                 | Возвращает новое изменяемое отображение с теми же сопоставлениями, что и в `ms`.

Подобно наборам, изменяемые отображения также поддерживают операции неразрушающего добавления `+`, `-` и `updated`, но 
они используются реже, потому что они включают в себя копирование коллекции. Вместо этого изменчивое отображение `m`
 обычно обновляется «на месте», используя два варианта `m (ключ) = значение` или `m += (ключ -> значение)`. Существует 
 также вариант `m put (key, value)`, который возвращает значение `Option`, которое содержит значение, ранее связанное с 
 ключом, или `None`, если ранее ключ не существовал в отображении.

`getOrElseUpdate` полезен для доступа к отображениям, которые действуют как кеши. Скажем, у вас 'дорогое' вычисление, 
вызванное вызовом функции `f`:

```scala
    scala> def f(x: String) = {
                 println("taking my time."); sleep(100)
                 x.reverse }
    f: (x: String)String
```

Предположим далее, что `f` не имеет побочных эффектов, поэтому повторное использование этого же аргумента всегда даст 
тот же результат. В этом случае вы могли бы сэкономить время, сохранив ранее рассчитанные привязки аргументов и 
результатов функции `f` в отображении и только вычисляя результат `f`, если результат аргумента там не был найден. 
Можно сказать, что отображение представляет собой кэш для вычислений функции `f`.

```scala
    scala> val cache = collection.mutable.Map[String, String]()
    cache: scala.collection.mutable.Map[String,String] = Map()
```

Теперь вы можете создать более эффективную кеширующую версию функции `f`:

```scala
    scala> def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
      cachedF: (s: String)String
    scala> cachedF("abc")
      taking my time.
      res3: String = cba
    scala> cachedF("abc")
      res4: String = cba
```

Обратите внимание, что второй аргумент `getOrElseUpdate` вызывается «по-имени», поэтому вычисление `f(«abc»)` выше 
выполняется только в том случае, если `getOrElseUpdate` требует значения его второго аргумента, что точно, если его 
первый аргумент не найден в отображении `cache`. Вы также могли бы реализовать `cachedF` напрямую, используя только 
основные операции с картами, но для этого потребуется больше кода:

```scala
    def cachedF(arg: String) = cache get arg match {
      case Some(result) => result
      case None =>
        val result = f(x)
        cache(arg) = result
        result
    }
```

### Синхронизированные множества (sets) и отображения (maps)

Чтобы получить потокобезопасное изменяемое отображение, вы можете смешивать типаж `SynchronizedMap` с любой конкретной 
реализацией отображения. Например, вы можете подмешать `SynchronizedMap` в `HashMap`, как показано в приведенном ниже 
коде. Этот пример начинается с импорта двух типажей: `Map` и `SynchronizedMap` и одного класса `HashMap` из пакета 
`scala.collection.mutable`. Остальная часть примера - это определение одиночного объекта `MapMaker`, который объявляет 
один метод `makeMap`. Метод `makeMap` декларирует тип возвращаемого результата как изменяемое отображение строковых 
ключей для строковых значений.

```scala
    import scala.collection.mutable.{Map, SynchronizedMap, HashMap}
      object MapMaker {
        def makeMap: Map[String, String] = {
            new HashMap[String, String] with SynchronizedMap[String, String] {
              override def default(key: String) =
                "Почему ты хочешь знать?"
            }
        }
      }
```

Первый оператор внутри тела `makeMap` создает новый измененный `HashMap`, который смешивается с типажом `SynchronizedMap`:

```scala
    new HashMap[String, String] with SynchronizedMap[String, String]
```

Учитывая этот код, компилятор Скала генерирует синтетический подкласс `HashMap`, который смешивается в `SynchronizedMap`
 и создает (и возвращает) его экземпляр. Этот синтетический класс также переопределяет метод с именем `default`, из-за этого кода:

```scala
    override def default(key: String) =
      "Почему ты хочешь знать?"
```

Если вы попросите отображение дать вам значение для определенного ключа, но у него нет сопоставления для этого ключа, 
вы по умолчанию получите исключение `NoSuchElementException`. Однако, если вы определяете новый класс отображения и 
переопределяете метод по умолчанию, ваше новое отображение вернет значение, возвращаемое по умолчанию при запросе с 
несуществующим ключом. Таким образом, синтетический подкласс `HashMap`, сгенерированный компилятором из кода в коде
синхронизированного отображения, вернет несколько строку ответа `Почему ты хочешь знать?` При запросе с несуществующим ключом.

Поскольку изменяемое отображение, возвращаемое методом `makeMap`, смешивается с типажом `SynchronizedMap`, оно может 
использоваться несколькими потоками одновременно. Каждый доступ к отображению будет синхронизирован. Вот пример 
использования отображения одним потоком в интерпретаторе:

```scala
    scala> val capital = MapMaker.makeMap  
      capital: scala.collection.mutable.Map[String,String] = Map()
      
    scala> capital ++ List("US" -> "Washington", "France" -> "Paris", "Japan" -> "Tokyo")
      res0: scala.collection.mutable.Map[String,String] = Map(France -> Paris, US -> Washington, Japan -> Tokyo)
    scala> capital("Japan")
      res1: String = Tokyo
    scala> capital("New Zealand")
      res2: String = Почему ты хочешь знать?
    scala> capital += ("New Zealand" -> "Wellington")
    scala> capital("New Zealand")                    
      res3: String = Wellington
```

Вы можете создавать синхронизированные наборы аналогично тому, как вы создаете синхронизированные отображения. Например, 
вы можете создать синхронизированный `HashSet`, перемещая в свойстве `SynchronizedSet`, например:

```scala
    import scala.collection.mutable
    
    val synchroSet = new mutable.HashSet[Int] with mutable.SynchronizedSet[Int]
```

Наконец, если вы собираетесь использовать синхронизированные коллекции, вы можете также рассмотреть параллельные
 коллекции `java.util.concurrent`.

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Collections/blob/master/readme.md)